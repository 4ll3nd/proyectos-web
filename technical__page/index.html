<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <nav class="nav" id="navbar">
        <div class="div-tittle">
        <header class="tittle">Python</header>
        </div>
        <ul class="nav-bar-ul">
            <li class="nav-li">
                <a href="#Filosofia" class="nav-link">Filosofia</a>
            </li>
            <li class="nav-li">
                <a href="#Historia" class="nav-link">Historia</a>
            </li>
            <li class="nav-li">
                <a href="#Caracteristicas_y_paradigmas" class="nav-link">Caracteristicas y paradigmas</a>
            </li>
            <li class="nav-li">
                <a href="#Modo_interactivo" class="nav-link">Modo interactivo</a>
            </li>
            <li class="nav-li">
                <a href="#Elementos_del_lenguaje_y_sintaxis" class="nav-link">Elementos del lenguaje y sintaxis</a>
            </li>
            <li class="nav-li">
                <a href="#Comentarios" class="nav-link">Comentarios</a>
            </li>
            <li class="nav-li">
                <a href="#Variables" class="nav-link">Variables</a>
            </li>
            <li class="nav-li">
                <a href="#Condicionales" class="nav-link">Condicionales</a>
            </li>
            <li class="nav-li">
                <a href="#Bucle_for" class="nav-link">Bucle for</a>
            </li>
            <li class="nav-li">
                <a href="#Bucle_while" class="nav-link">Bucle while</a>
            </li>
            <li class="nav-li">
                <a href="#Listas_y_tuplas" class="nav-link">Listas y tuplas</a>
            </li>
            <li class="nav-li">
                <a href="#Sentencia_switch_case" class="nav-link">Sentencia switch case</a>
            </li>
            <li class="nav-li">
                <a href="#Diccionarios" class="nav-link">Diccionarios</a>
            </li>
            <li class="nav-li">
                <a href="#Referencias" class="nav-link">Referencias</a>
            </li>
        </ul>
    </nav>
    <main class="main" id="main-doc">

        <section class="main-section" id="Filosofia">
            <header>Filosofia</header>
            <p class="main-section-p">Los usuarios de Python se refieren a menudo a la filosofía de Python que es bastante análoga a la filosofía de Unix. El código que siga los principios de Python se dice que es "pythónico". Estos principios fueron descritos por el desarrollador de Python Tim Peters en El Zen de Python.</p>
            <ul class="main-ul">
                <li>Bello es mejor que feo</li>
                <li>Plano es mejor que anidado.</li>
                <li>La legibilidad cuenta.</li>
                <li>Lo práctico gana a lo puro.</li>
                <li>Frente a la ambigüedad, rechaza la tentación de adivinar.</li>
            </ul>
        </section>

        <section class="main-section" id="Historia">
            <header>Historia</header>
            <p class="main-section-p">El 20 de febrero de 1991, van Rossum publicó el código por primera vez en alt.sources, con el número de versión 0.9.0.9​ En esta etapa del desarrollo ya estaban presentes clases con herencia, manejo de excepciones, funciones y los tipos modulares, como: str, list, dict, entre otros. Además en este lanzamiento inicial aparecía un sistema de módulos adoptado de Modula-3; van Rossum describe el módulo como «una de las mayores unidades de programación de Python».4​ El modelo de excepciones en Python es parecido al de Modula-3, con la adición de una cláusula else.5​ En el año 1994 se formó comp.lang.python, el foro de discusión principal de Python, marcando un hito en el crecimiento del grupo de usuarios de este lenguaje.<br>Python 2, es decir Python 2.7.x, fue oficialmente descontinuado el 1 de enero de 2020 (primero planeado para 2015) después de lo cual no se publicarán parches de seguridad y otras mejoras para él.20​21​ Con el final del ciclo de vida de Python 2, solo tienen soporte la rama Python 3.6.x22​ y posteriores.

                En la actualidad, Python se aplica en los campos de inteligencia artificial y machine learning.23</p>
        </section>

        <section class="main-section" id="Caracteristicas_y_paradigmas">

            <header>Caracteristicas y paradigmas</header>
            <p class="main-section-p">Python es un lenguaje de programación multiparadigma. Esto significa que más que forzar a los programadores a adoptar un estilo particular de programación, permite varios estilos: programación orientada a objetos, programación imperativa y programación funcional. Otros paradigmas están soportados mediante el uso de extensiones.

                Python usa tipado dinámico y conteo de referencias para la gestión de memoria.
                
                Una característica importante de Python es la resolución dinámica de nombres; es decir, lo que enlaza un método y un nombre de variable durante la ejecución del programa (también llamado enlace dinámico de métodos).
                
                Otro objetivo del diseño del lenguaje es la facilidad de extensión. Se pueden escribir nuevos módulos fácilmente en C o C++. Python puede incluirse en aplicaciones que necesitan una interfaz programable.
                
                Aunque la programación en Python podría considerarse en algunas situaciones hostil a la programación funcional tradicional del Lisp, existen bastantes analogías entre Python y los lenguajes minimalistas de la familia Lisp como puede ser Scheme.</p>
        </section>

        <section class="main-section" id="Modo_interactivo">

            <header>Modo interactivo</header>
            <p class="main-section-p">El intérprete de Python estándar incluye un modo interactivo en el cual se escriben las instrucciones en una especie de intérprete de comandos: las expresiones pueden ser introducidas una a una, pudiendo verse el resultado de su evaluación inmediatamente, lo que da la posibilidad de probar porciones de código en el modo interactivo antes de integrarlo como parte de un programa. Esto resulta útil tanto para las personas que se están familiarizando con el lenguaje como para los programadores más avanzados.

                Existen otros programas, tales como IDLE, bpython o IPython,que añaden funcionalidades extra al modo interactivo, como la compleción automática de código y el coloreado de la sintaxis del lenguaje. <br>
                Ejemplo de modo interactivo<br>
                <code class="main-code">>>> 1 + 1
                    2
                    >>> a = range(10) <br>
                    >>> print(list(a)) <br>
                    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
                </code>
            </p>
        </section>

        <section class="main-section" id="Elementos_del_lenguaje_y_sintaxis">

            <header>Elementos del lenguaje y sintaxis</header>
            <p class="main-section-p">Python está destinado a ser un lenguaje de fácil lectura. Su formato es visualmente ordenado y, a menudo, usa palabras clave en inglés donde otros idiomas usan puntuación. A diferencia de muchos otros lenguajes, no utiliza corchetes para delimitar bloques y se permiten puntos y coma después de las declaraciones, pero rara vez, si es que alguna vez, se utilizan. Tiene menos excepciones sintácticas y casos especiales que C o Pascal.

                Diseñado para ser leído con facilidad, una de sus características es el uso de palabras donde otros lenguajes utilizarían símbolos. Por ejemplo, los operadores lógicos !, || y && en Python se escriben not, or y and, respectivamente. Curiosamente el lenguaje Pascal es junto con COBOL uno de los lenguajes con muy clara sintaxis y ambos son de la década del 70. La idea del código claro y legible no es algo nuevo.
                
                El contenido de los bloques de código (bucles, funciones, clases, etc.) es delimitado mediante espacios o tabuladores, conocidos como indentación, antes de cada línea de órdenes pertenecientes al bloque.28​ Python se diferencia así de otros lenguajes de programación que mantienen como costumbre declarar los bloques mediante un conjunto de caracteres, normalmente entre llaves {}.29​30​ Se pueden utilizar tanto espacios como tabuladores para sangrar el código, pero se recomienda no mezclarlos</p> <br>
                <p>Función factorial en Python (sangría obligatoria)</p>
                <code class="main_code">
                    def factorial(x):
                    assert x >= 0 and x % 1 == 0, "x debe ser un entero mayor o igual a 0." <br>
                        if x == 0: <br>
                    return 1 <br>
                    else: <br>
                        return x * factorial(x - 1)
                </code>
            <p>Debido al significado sintáctico de la sangría, cada instrucción debe estar contenida en una sola línea. No obstante, si por legibilidad se quiere dividir la instrucción en varias líneas, añadiendo una barra invertida \ al final de una línea, se indica que la instrucción continúa en la siguiente.

                Estas instrucciones son equivalentes:</p>
                <code class="main_code"> 
                     lista=['valor 1','valor 2','valor 3'] <br>
                    cadena='Esto es una cadena bastante larga'
                </code>
                <code class="main_code">
                    lista=['valor 1','valor 2' \ <br>
                    ,'valor 3']
                    cadena='Esto es una cadena ' \
                     'bastante larga'
                </code>
        </section>

        <section class="main-section"  id="Comentarios">

            <header>Comentarios</header>
            <p class="main-section-p">Los comentarios se pueden poner de dos formas. La primera y más apropiada para comentarios largos es utilizando la notación ''' comentario ''', tres apóstrofos de apertura y tres de cierre. La segunda notación utiliza el símbolo #, y se extienden hasta el final de la línea.

                El intérprete no tiene en cuenta los comentarios, lo cual es útil si deseamos poner información adicional en el código. Por ejemplo, una explicación sobre el comportamiento de una sección del programa.</p>
                <code class="main_code">
                    '''
                    Comentario más largo en una línea en Python <br>
                    '''
                    print("Hola mundo") # También es posible añadir un comentario al final describe una línea de código
                </code>
        </section>

        <section class="main-section" id="Variables">
            <header>Variables</header>
            <p class="main-section-p">Las variables se definen de forma dinámica, lo que significa que no se tiene que especificar cuál es su tipo de antemano y puede tomar distintos valores en otro momento, incluso de un tipo diferente al que tenía previamente. Se usa el símbolo = para asignar valores.</p>
            <code class="main_code">
                x = 1 <br>
                x = "texto" # Esto es posible porque los tipos son asignados dinámicamente  
            </code>
        </section>

        <section class="main-section" id="Condicionales">
            <header>Condicionales</header>
            <p class="main-section-p">Una sentencia condicional (if) ejecuta su bloque de código interno solo si se cumple cierta condición. Se define usando la palabra clave if seguida de la condición, y el bloque de código. Si existen condiciones adicionales, se introducen usando la palabra clave elif seguida de la condición y su bloque de código. Las condiciones se evalúan de manera secuencial hasta encontrar la primera que sea verdadera, y su bloque de código asociado es el único que se ejecuta. Opcionalmente, puede haber un bloque final (la palabra clave else seguida de un bloque de código) que se ejecuta solo cuando todas las condiciones anteriores fueron falsas.</p>
            <code class="main_code">
                <br>>>> verdadero = True
                <br>>>> if verdadero: # No es necesario poner "verdadero == True" <br>
                ...     print("Verdadero")
                ... else:
                ...     print("Falso")
                ...
                Verdadero
                <br>>>> lenguaje = "Python"
                <br>>>> if lenguaje == "C": # lenguaje no es "C", por lo que este bloque se obviará  y evaluará la               siguiente condición <br>
                ...     print("Lenguaje de programación: C")
                ... elif lenguaje == "Python": # Se pueden añadir tantos bloques "elif" como se quiera <br>
                ...     print("Lenguaje de programación: Python")
                ... else: # En caso de que ninguna de las anteriores condiciones fuera cierta, se ejecutaría                este bloque <br>
                ...     print("Lenguaje de programación: indefinido")
                ...
                Lenguaje de programación: Python
                <br>>>> if verdadero and lenguaje == "Python": # Uso de "and" para comprobar que ambas condiciones              son verdaderas <br>
                ...     print("Verdadero y Lenguaje de programación: Python")
                ...
                Verdadero y Lenguaje de programación: Python
            </code>
        </section>

        <section class="main-section" id="Bucle_for">
            <header>Bucle for</header>
            <p class="main-section-p">El bucle for es similar a foreach en otros lenguajes. Recorre un objeto iterable, como una lista, una tupla o un generador, y por cada elemento del iterable ejecuta el bloque de código interno. Se define con la palabra clave for seguida de un nombre de variable, seguido de in, seguido del iterable, y finalmente el bloque de código interno. En cada iteración, el elemento siguiente del iterable se asigna al nombre de variable especificado:</p>
            <code>
                <br>>>> lista = ["a", "b", "c"]
                <br>>>> for i in lista: # Iteramos sobre una lista, que es iterable
                ...     print(i)
                ...
                a
                b
                c
                <br>>>> cadena = "abcdef"
                <br>>>> for i in cadena: # Iteramos sobre una cadena, que también es iterable
                ...     print(i, end=', ') # Añadiendo end=', ' al final hacemos que no introduzca un salto de línea, sino una coma y un espacio
                ...
                a, b, c, d, e, f,
            </code>
        </section>

        <section class="main-section" id="Bucle_while">
            <header>Bucle while</header>
            <p class="main-section-p">El bucle while evalúa una condición y, si es verdadera, ejecuta el bloque de código interno. Continúa evaluando y ejecutando mientras la condición sea verdadera. Se define con la palabra clave while seguida de la condición, y a continuación el bloque de código interno:</p>
            <code>
                >>> numero = 0
                >>> while numero < 10:
                ...     print(numero, end=" ")
                ...     numero += 1  # Un buen programador modificará las variables de control al finalizar el ciclo while
                ...
                0 1 2 3 4 5 6 7 8 9
            </code>
        </section>

        <section class="main-section" id="Listas_y_tuplas">
            <header>Listas y Tuplas</header>
            <ul class="main-ul">
                <li>Para declarar una lista se usan los corchetes [], en cambio, para declarar una tupla se usan los paréntesis (). En ambas los elementos se separan por comas, y en el caso de las tuplas es necesario que tengan como mínimo una coma</li>
                <li>Tanto las listas como las tuplas pueden contener elementos de diferentes tipos. No obstante las listas suelen usarse para elementos del mismo tipo en cantidad variable mientras que las tuplas se reservan para elementos distintos en cantidad fija.</li>
                <li>Para acceder a los elementos de una lista o tupla se utiliza un índice entero (empezando por "0", no por "1"). Se pueden utilizar índices negativos para acceder elementos a partir del final.</li>
                <li>Las listas se caracterizan por ser mutables, es decir, se puede cambiar su contenido en tiempo de ejecución, mientras que las tuplas son inmutables ya que no es posible modificar el contenido una vez creada.</li>
            </ul>
            <code>
                <br>>>> lista = ["abc", 42, 3.1415]
                <br>>>> lista[0] # Acceder a un elemento por su índice
                'abc'
                <br>>>> lista[-1] # Acceder a un elemento usando un índice negativo
                3.1415
                <br>>>> lista.append(True) # Añadir un elemento al final de la lista
                <br>>>> lista
                ['abc', 42, 3.1415, True]
                <br>>>> del lista[3] # Borra un elemento de la lista usando un índice (en este caso: True)
                <br>>>> lista[0] = "xyz" # Re-asignar el valor del primer elemento de la lista
                <br>>>> lista[0:2] # Mostrar los elementos de la lista del índice "0" al "2" (sin incluir este último)
                ['xyz', 42]
                <br>>>> lista_anidada = [lista, [True, 42L]] # Es posible anidar listas
                <br>>>> lista_anidada
                [['xyz', 42, 3.1415], [True, 42L]]
                <br>>>> lista_anidada[1][0] # Acceder a un elemento de una lista dentro de otra lista (del segundo elemento, mostrar el primer elemento)
            </code>
            <code>
                >>> tupla = ("abc", 42, 3.1415)
                <br>>>> tupla[0] # Acceder a un elemento por su índice
                'abc'
                <br>>>> del tupla[0] # No es posible borrar (ni añadir) un elemento en una tupla, lo que provocará una excepción
                ( Excepción )
                <br>>>> tupla[0] = "xyz" # Tampoco es posible re-asignar el valor de un elemento en una tupla, lo que también provocará una excepción
                ( Excepción )
                <br>>>> tupla[0:2] # Mostrar los elementos de la tupla del índice "0" al "2" (sin incluir este último)
                ('abc', 42)
                <br>>>> tupla_anidada = (tupla, (True, 3.1415)) # También es posible anidar tuplas
                <br>>>> 1, 2, 3, "abc" # Esto también es una tupla, aunque es recomendable ponerla entre paréntesis (recuerda que requiere, al menos, una coma)
                (1, 2, 3, 'abc')
                <br>>>> (1) # Aunque entre paréntesis, esto no es una tupla, ya que no posee al menos una coma, por lo que únicamente aparecerá el valor
                1
                <br>>>> (1,) # En cambio, en este otro caso, sí es una tupla
                (1,)
                <br>>>> (1, 2) # Con más de un elemento no es necesaria la coma final
                (1, 2)
               <br>>>> (1, 2,) # Aunque agregarla no modifica el resultado
                (1, 2)
            </code>
        </section>

        <section class="main-section" id="Sentencia_switch_case">
            <header>Sentencia switch case</header>
            <p class="main-section-p">Python cuenta con la estructura switch-case desde la versión 3.10. Esta tiene el nombre de Structural Pattern Matching. <br>
                <code>
                    match variable:   
                   <br>    case condicion:
                   <br>    # codigo
                   <br>    case condicion:
                   <br>    # codigo
                   <br>    case condicion:
                   <br>    # codigo
                   <br>    case _:
                       # codigo
               </code>
                Cabe destacar que esta funcionalidad es considerablemente más compleja que el conocido switch-case de la mayoría de lenguajes, ya que no solo permite realizar una comparación del valor, si no que también puede comprobar el tipo del objeto, y sus atributos. Además que también puede realizar un desempaquetado directo de secuencias de datos, y comprobarlos de forma específica.
                
                En el siguiente ejemplo, se comprueban los atributos de nuestra instancia de Punto. Si estos no son iguales a x10 e y40, se pasará a la siguiente condición.
                
                Es importante anotar que Punto(x=10, y=40) no está construyendo un nuevo objeto, aunque pueda parecerlo.</p>
                <code>
                   from dataclasses import dataclass

                    @dataclass
                    class Punto:
                        x: int
                        y: int
                    
                    coordenada = Punto(10, 34)
                    
                    match coordenada:
                        case Punto(x=10, y=40):     # los atributos "x" e "y" tienen el valor specificado
                            print("Coordenada 10, 40")
                        case Punto():   # si es una instancia de Punto
                            print("es un punto")
                        case _:         # ninguna condición cumplida (default)
                            print("No es un punto")
                </code>
        </section>

        <section class="main-section" id="Diccionarios">
            <header>Diccionarios</header>
            <ul class="main-ul">
                <li>Para declarar un diccionario se usan las llaves {}. Contienen elementos separados por comas, donde cada elemento está formado por un par clave:valor (el símbolo : separa la clave de su valor correspondiente).</li>
                <li>Los diccionarios son mutables, es decir, se puede cambiar el contenido de un valor en tiempo de ejecución.</li>
                <li>En cambio, las claves de un diccionario deben ser inmutables. Esto quiere decir, por ejemplo, que no podremos usar ni listas ni diccionarios como claves.</li>
                <li>El valor asociado a una clave puede ser de cualquier tipo de dato, incluso un diccionario.
                </li>
            </ul>
            <code>
                <br>>>> diccionario = {"cadena": "abc", "numero": 42, "lista": [True, 42L]} # Diccionario que tiene diferentes valores por cada clave, incluso una lista
                <br>>>> diccionario["cadena"] # Usando una clave, se accede a su valor
                'abc'
                <br>>>> diccionario["lista"][0] # Acceder a un elemento de una lista dentro de un valor (del valor de la clave "lista", mostrar el primer elemento)
                True
                <br>>>> diccionario["cadena"] = "xyz" # Re-asignar el valor de una clave
                <br>>>> diccionario["cadena"]
                'xyz'
                <br>>>> diccionario["decimal"] = 3.1415927 # Insertar un nuevo elemento clave:valor
                <br>>>> diccionario["decimal"]
                3.1415927
                <br>>>> diccionario_mixto = {"tupla": (True, 3.1415), "diccionario": diccionario} # También es posible que un valor sea un diccionario
                <br>>>> diccionario_mixto["diccionario"]["lista"][1] # Acceder a un elemento dentro de una lista, que se encuentra dentro de un diccionario
                42L
                <br>>>> diccionario = {("abc",): 42} # Sí es posible que una clave sea una tupla, pues es inmutable
                <br>>>> diccionario = {["abc"]: 42} # No es posible que una clave sea una lista, pues es mutable, lo que provocará una excepción
            </code>
        </section>

        <section class="main-section" id="Referencias">
            <header>Referencias</header>
            <span>Toda la informacion presente en esta pagina se extrajo de <a href="">https://es.wikipedia.org/wiki/Python</a></span>
        </section>

    </main>
</body>
</html>